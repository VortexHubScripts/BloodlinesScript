-- Boss Farm Module for Bloodlines (Optimized & Integrated)
-- Designed to work seamlessly with main Bloodlines script

local BossFarm = {}

-- ============================================
-- SERVICES & DEPENDENCIES
-- ============================================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local dataEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("DataEvent")

-- ============================================
-- SETTINGS
-- ============================================
getgenv().BossFarmSettings = {
    Enabled = false,
    SelectedBosses = {},
    ServerHopIfChakraSense = false,
    ServerHopIfNoBoss = false,
    AttackInterval = 0.5,
    HealthCheckInterval = 0.3,
    PlayerDetectionRadius = 100,
    FarmHeightOffset = 15,
    SafeHeightOffset = 30
}

-- ============================================
-- BOSS DATABASE & CONFIGURATIONS
-- ============================================

--[[
    BOSS CONFIGURATION STRUCTURE:
    
    farmHeight: Distance from boss (positive = above, negative = below)
    positionAbove: true = farm above boss, false = farm below boss
    
    dangerousAnimations: Table of animation IDs to avoid
        - Can use "teleport" mode or "height" mode
        - teleport: Teleports to specific position
        - height: Moves to safeHeight offset
    
    animationResponse: "teleport" or "height" (default: "height")
    safePosition: Vector3 position to teleport to (only for "teleport" mode)
    safeHeight: Height offset when using "height" mode
    
    requiresSpawn: true if boss needs player input to spawn (for future implementation)
    spawnFunction: Custom function to spawn boss (optional)
]]

local BOSS_CONFIGS = {
    ["Barbarit The Hallowed"] = {
        farmHeight = 16,
        safeHeight = 55,
        positionAbove = true,
        dangerousAnimations = {
            ["rbxassetid://9954909571"] = true
        },
        animationResponse = "height", -- Move up when animation detected
        requiresSpawn = false
    },
    
    ["Wooden Golem"] = {
        farmHeight = 15,
        positionAbove = true,
        dangerousAnimations = {
            ["rbxassetid://120758909308511"] = true,
            ["rbxassetid://116907126244057"] = true
        },
        animationResponse = "teleport", -- Teleport to safe position
        safePosition = Vector3.new(-2950.580, 321.173, -275.704), -- Safe spot position
        requiresSpawn = false
    },
    
    ["Chakra Knight"] = {
        farmHeight = 15,
        safeHeight = 25,
        positionAbove = false,
        dangerousAnimations = {
            ["rbxassetid://10141233349"] = true
        },
        animationResponse = "height",
        requiresSpawn = false
    },
    
    ["Hallowed Chakra Knight"] = {
        farmHeight = 15,
        safeHeight = 25,
        positionAbove = false,
        dangerousAnimations = {
            ["rbxassetid://10141233349"] = true
        },
        animationResponse = "height",
        requiresSpawn = false
    },
    
    ["Tairock"] = {
        farmHeight = 11,
        safeHeight = 30,
        positionAbove = false,
        dangerousAnimations = {},
        animationResponse = "height",
        requiresSpawn = false
    },
    
    ["Hallowed Tairock"] = {
        farmHeight = 11,
        safeHeight = 30,
        positionAbove = false,
        dangerousAnimations = {},
        animationResponse = "height",
        requiresSpawn = false
    },
    
    -- TEMPLATE FOR MANDA (requires spawn - to be implemented)
    ["Manda"] = {
        farmHeight = 20,
        safeHeight = 40,
        positionAbove = true,
        dangerousAnimations = {},
        animationResponse = "height",
        requiresSpawn = true, -- Requires player input to spawn
        -- spawnFunction will be added later when you explain the spawn process
    }
}

-- Generate boss database from configs
local bossDatabase = {}
for bossName, _ in pairs(BOSS_CONFIGS) do
    table.insert(bossDatabase, bossName)
end
table.sort(bossDatabase)

local SAFE_SPOT = Vector3.new(-2950.580, 321.173, -275.704)

-- ============================================
-- STATE MANAGEMENT
-- ============================================
local State = {
    running = false,
    currentBoss = nil,
    connections = {},
    animationStates = {}, -- Stores {dangerous: bool, responseType: "teleport"|"height", safePos: Vector3?}
    lastBossPosition = nil,
    healthThreshold = 0,
    farmThread = nil,
    teleportMode = false -- true when in teleport evasion mode
}

-- ============================================
-- UTILITY FUNCTIONS
-- ============================================
local Utils = {}

function Utils.log(message, level)
    local prefix = "[Boss Farm]"
    if level == "warn" then
        warn(prefix, message)
    else
        print(prefix, message)
    end
end

function Utils.notify(text, duration)
    if _G.NotificationLib then
        _G.NotificationLib:MakeNotification({
            Title = "Boss Farm",
            Text = text,
            Duration = duration or 3
        })
    end
end

function Utils.getPlayerData()
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    
    if not rootPart or not humanoid then return nil end
    
    return {
        character = character,
        rootPart = rootPart,
        humanoid = humanoid
    }
end

function Utils.isValidBoss(boss)
    if not boss or not boss.Parent or not boss:IsA("Model") then
        return false
    end
    
    local humanoid = boss:FindFirstChildOfClass("Humanoid")
    local rootPart = boss:FindFirstChild("HumanoidRootPart")
    
    return humanoid and rootPart and humanoid.Health > 0
end

function Utils.disconnectAll(connections)
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if conn and typeof(conn) == "RBXScriptConnection" then
            pcall(function() conn:Disconnect() end)
        end
        connections[i] = nil
    end
end

function Utils.getInDanger()
    return getgenv().inDanger or false
end

-- ============================================
-- BOSS SPAWNING (FOR BOSSES THAT REQUIRE INPUT)
-- ============================================
local BossSpawn = {}

--[[
    This section handles bosses that require player input to spawn.
    You'll need to provide the spawn logic for each boss.
    
    Example structure:
    function BossSpawn.spawnManda()
        -- Your spawn logic here
        -- Return true if successful, false otherwise
        return true
    end
]]

function BossSpawn.canSpawn(bossName)
    local config = BOSS_CONFIGS[bossName]
    return config and not config.requiresSpawn
end

function BossSpawn.attemptSpawn(bossName)
    local config = BOSS_CONFIGS[bossName]
    if not config then return false end
    
    if not config.requiresSpawn then
        return true -- Boss spawns naturally, no action needed
    end
    
    -- Check if custom spawn function exists
    if config.spawnFunction then
        Utils.log(string.format("Attempting to spawn %s...", bossName))
        return config.spawnFunction()
    end
    
    Utils.log(string.format("%s requires spawn but no spawn function defined", bossName), "warn")
    return false
end

-- ============================================
-- BOSS DETECTION
-- ============================================
local Detection = {}

function Detection.findBoss(bossName)
    for _, child in pairs(workspace:GetChildren()) do
        if child.Name == bossName and Utils.isValidBoss(child) then
            return child
        end
    end
    return nil
end

function Detection.findAnySelectedBoss()
    local selectedBosses = getgenv().BossFarmSettings.SelectedBosses
    
    -- Priority order: try to find bosses in the order they appear in the table
    for bossName, isSelected in pairs(selectedBosses) do
        if isSelected then
            local boss = Detection.findBoss(bossName)
            if boss then
                return boss
            end
        end
    end
    
    return nil
end

function Detection.getSelectedBossList()
    local selectedBosses = getgenv().BossFarmSettings.SelectedBosses
    local list = {}
    
    for bossName, isSelected in pairs(selectedBosses) do
        if isSelected then
            table.insert(list, bossName)
        end
    end
    
    return list
end

function Detection.isPlayerNearby(boss, radius)
    local rootPart = boss:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            if character then
                local playerRoot = character:FindFirstChild("HumanoidRootPart")
                if playerRoot then
                    local distance = (playerRoot.Position - rootPart.Position).Magnitude
                    if distance <= radius then
                        return true, player.Name, math.floor(distance)
                    end
                end
            end
        end
    end
    
    return false
end

-- ============================================
-- ANIMATION TRACKING
-- ============================================
local Animation = {}

function Animation.setup(boss, config)
    if not config.dangerousAnimations then return end
    
    local humanoid = boss:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return end
    
    State.animationStates[boss] = { 
        dangerous = false,
        responseType = config.animationResponse or "height",
        safePosition = config.safePosition
    }
    
    local conn = animator.AnimationPlayed:Connect(function(track)
        local animId = track.Animation.AnimationId
        
        if config.dangerousAnimations[animId] then
            State.animationStates[boss].dangerous = true
            
            -- Handle different response types
            if config.animationResponse == "teleport" and config.safePosition then
                State.teleportMode = true
                Utils.log(string.format("Dangerous animation! Teleporting to safe position"))
            else
                Utils.log("Dangerous animation! Moving to safe height")
            end
            
            track.Stopped:Connect(function()
                if State.animationStates[boss] then
                    State.animationStates[boss].dangerous = false
                    State.teleportMode = false
                    Utils.log("Dangerous animation ended, resuming farm")
                end
            end)
        end
    end)
    
    table.insert(State.connections, conn)
end

function Animation.isDangerous(boss)
    local state = State.animationStates[boss]
    return state and state.dangerous or false
end

function Animation.getResponseType(boss)
    local state = State.animationStates[boss]
    if state then
        return state.responseType, state.safePosition
    end
    return "height", nil
end

function Animation.cleanup(boss)
    State.animationStates[boss] = nil
end

-- ============================================
-- TELEPORT SYSTEM
-- ============================================
local Teleport = {}

function Teleport.toSafeSpot(continuous)
    local playerData = Utils.getPlayerData()
    if not playerData then return nil end
    
    Utils.log("Moving to safe spot" .. (continuous and " (continuous)" or ""))
    
    if not continuous then
        playerData.rootPart.CFrame = CFrame.new(SAFE_SPOT)
        return nil
    end
    
    local conn = RunService.Heartbeat:Connect(function()
        local pData = Utils.getPlayerData()
        if pData and pData.rootPart and pData.rootPart.Parent then
            pData.rootPart.CFrame = CFrame.new(SAFE_SPOT)
        end
    end)
    
    table.insert(State.connections, conn)
    return conn
end

function Teleport.toBoss(boss, config)
    if not Utils.isValidBoss(boss) then return nil end
    
    local bossRoot = boss:FindFirstChild("HumanoidRootPart")
    if not bossRoot then return nil end
    
    State.lastBossPosition = bossRoot.Position
    
    local conn = RunService.Heartbeat:Connect(function()
        if not State.running then return end
        
        local pData = Utils.getPlayerData()
        if not pData then return end
        
        -- Update position if boss still exists
        if bossRoot and bossRoot.Parent then
            State.lastBossPosition = bossRoot.Position
        end
        
        -- Check for dangerous animation
        local isDangerous = Animation.isDangerous(boss)
        
        if isDangerous then
            -- Get response type (teleport or height)
            local responseType, safePos = Animation.getResponseType(boss)
            
            if responseType == "teleport" and safePos then
                -- Teleport to specific safe position
                pData.rootPart.CFrame = CFrame.new(safePos)
            else
                -- Move to safe height (original behavior)
                local height = config.safeHeight or 30
                local yOffset = config.positionAbove and height or -height
                local targetPos = State.lastBossPosition + Vector3.new(0, yOffset, 0)
                local lookAt = CFrame.new(targetPos, State.lastBossPosition)
                pData.rootPart.CFrame = lookAt
            end
        else
            -- Normal farming position
            local height = config.farmHeight
            local yOffset = config.positionAbove and height or -height
            local targetPos = State.lastBossPosition + Vector3.new(0, yOffset, 0)
            local lookAt = CFrame.new(targetPos, State.lastBossPosition)
            pData.rootPart.CFrame = lookAt
        end
    end)
    
    table.insert(State.connections, conn)
    return conn
end

-- ============================================
-- SERVER HOP SYSTEM
-- ============================================
local ServerHop = {}

function ServerHop.execute()
    Utils.log("Initiating server hop...")
    
    -- Wait if in danger
    if Utils.getInDanger() then
        Utils.log("In combat, waiting...")
        Utils.notify("In combat! Waiting...", 3)
        
        Teleport.toSafeSpot(false)
        
        while Utils.getInDanger() do
            task.wait(0.5)
        end
        
        Utils.log("Out of combat, proceeding...")
        task.wait(1)
    end
    
    for attempt = 1, 5 do
        local success = pcall(function()
            local playerGui = LocalPlayer:WaitForChild("PlayerGui", 5)
            if not playerGui then return end
            
            local clientGui = playerGui:WaitForChild("ClientGui", 5)
            if not clientGui then return end
            
            local list = ServerHop.findServerList(clientGui)
            if not list then return end
            
            local validServers = ServerHop.getValidServers(list)
            if #validServers == 0 then return end
            
            local randomServer = validServers[math.random(1, #validServers)]
            
            for _, conn in pairs(getconnections(randomServer.button.MouseButton1Click)) do
                conn:Fire()
            end
        end)
        
        task.wait(2)
        
        if attempt < 5 then
            Utils.notify(string.format("Retry %d/5", attempt + 1), 2)
        end
    end
end

function ServerHop.findServerList(clientGui)
    -- Try Mainframe path
    local mainframe = clientGui:FindFirstChild("Mainframe")
    if mainframe then
        local rest = mainframe:FindFirstChild("Rest")
        if rest then
            local serverList = rest:FindFirstChild("ServerList")
            if serverList then
                local backdrop = serverList:FindFirstChild("BackDrop")
                if backdrop then
                    local list = backdrop:FindFirstChild("List")
                    if list and #list:GetChildren() > 0 then
                        return list
                    end
                end
            end
        end
    end
    
    -- Try MenuScreen path
    local menuScreen = clientGui:FindFirstChild("MenuScreen")
    if menuScreen then
        local serverList = menuScreen:FindFirstChild("ServerList")
        if serverList then
            local backdrop = serverList:FindFirstChild("BackDrop")
            if backdrop then
                return backdrop:FindFirstChild("List")
            end
        end
    end
    
    return nil
end

function ServerHop.getValidServers(list)
    local validServers = {}
    
    for _, frame in ipairs(list:GetChildren()) do
        if frame:IsA("Frame") and frame.Name == "ServerTemplate" then
            local playersLabel = frame:FindFirstChild("Players")
            local joinButton = frame:FindFirstChild("JoinButton")
            
            if playersLabel and joinButton and joinButton:IsA("TextButton") then
                local playerCount = tonumber(playersLabel.Text:match("%d+"))
                
                if playerCount and playerCount >= 10 then
                    table.insert(validServers, {
                        button = joinButton,
                        playerCount = playerCount
                    })
                end
            end
        end
    end
    
    return validServers
end

-- ============================================
-- COMBAT SYSTEM
-- ============================================
local Combat = {}

function Combat.startAttacking()
    local settings = getgenv().BossFarmSettings
    
    local thread = task.spawn(function()
        while State.running and State.currentBoss do
            task.wait(settings.AttackInterval)
            
            if State.running and State.currentBoss then
                pcall(function()
                    dataEvent:FireServer("CheckMeleeHit", nil, "NormalAttack", false)
                end)
            end
        end
    end)
    
    return thread
end

function Combat.enableNoclip()
    local conn = RunService.Stepped:Connect(function()
        if not State.running then return end
        
        local pData = Utils.getPlayerData()
        if not pData then return end
        
        for _, part in pairs(pData.character:GetDescendants()) do
            if part:IsA('BasePart') then
                part.CanCollide = false
            end
        end
    end)
    
    table.insert(State.connections, conn)
    return conn
end

-- ============================================
-- CHAKRA SENSE MONITOR
-- ============================================
local ChakraSense = {}

function ChakraSense.setup()
    if not getgenv().BossFarmSettings.ServerHopIfChakraSense then return end
    
    local cooldowns = ReplicatedStorage:FindFirstChild("Cooldowns")
    if not cooldowns then return end
    
    local function onChakraSenseUsed(playerName)
        if not State.running then return end
        if not getgenv().BossFarmSettings.ServerHopIfChakraSense then return end
        
        Utils.log(string.format("%s used Chakra Sense! Server hopping...", playerName))
        Utils.notify("Chakra Sense detected! Server hopping...", 3)
        
        -- Stop farm and server hop
        State.running = false
        Farm.cleanup()
        Teleport.toSafeSpot(false)
        task.wait(1)
        ServerHop.execute()
    end
    
    local function watchPlayer(playerFolder)
        local playerName = playerFolder.Name
        if playerName == LocalPlayer.Name then return end
        
        playerFolder.ChildAdded:Connect(function(child)
            if child:IsA("NumberValue") and child.Name == "Chakra Sense" then
                onChakraSenseUsed(playerName)
            end
        end)
    end
    
    for _, folder in pairs(cooldowns:GetChildren()) do
        if folder:IsA("Folder") then
            watchPlayer(folder)
        end
    end
    
    cooldowns.ChildAdded:Connect(function(folder)
        if folder:IsA("Folder") then
            watchPlayer(folder)
        end
    end)
end

-- ============================================
-- FARM LOGIC
-- ============================================
local Farm = {}

function Farm.start()
    if State.running then
        Utils.log("Farm already running")
        return
    end
    
    State.farmThread = task.spawn(function()
        State.running = true
        Utils.notify("Boss auto-farm started!", 3)
        
        -- Setup Chakra Sense monitoring
        ChakraSense.setup()
        
        while getgenv().BossFarmSettings.Enabled and State.running do
            Farm.cleanup()
            
            -- Find any selected boss
            local boss = Detection.findAnySelectedBoss()
            
            if not boss then
                if getgenv().BossFarmSettings.ServerHopIfNoBoss then
                    Utils.log("No selected bosses found, server hopping...")
                    Utils.notify("No bosses found! Server hopping...", 3)
                    Teleport.toSafeSpot(false)
                    task.wait(1)
                    ServerHop.execute()
                    break
                else
                    Utils.log("No bosses found, waiting...")
                    task.wait(5)
                    continue
                end
            end
            
            -- Check for nearby players
            local playerNearby, playerName = Detection.isPlayerNearby(
                boss, 
                getgenv().BossFarmSettings.PlayerDetectionRadius
            )
            
            if playerNearby then
                Utils.log(string.format("Player %s nearby, waiting...", playerName))
                task.wait(5)
                continue
            end
            
            -- Farm the boss
            Farm.farmBoss(boss)
            task.wait(0.5)
        end
        
        State.running = false
        State.currentBoss = nil
        Utils.log("Farm stopped")
    end)
end

function Farm.stop()
    getgenv().BossFarmSettings.Enabled = false
    State.running = false
    State.currentBoss = nil
    
    Farm.cleanup()
    
    if State.farmThread then
        pcall(function() task.cancel(State.farmThread) end)
        State.farmThread = nil
    end
    
    Utils.notify("Auto-farm stopped", 2)
end

function Farm.cleanup()
    Utils.disconnectAll(State.connections)
    
    for boss, _ in pairs(State.animationStates) do
        Animation.cleanup(boss)
    end
end

function Farm.farmBoss(boss)
    local pData = Utils.getPlayerData()
    if not pData then return end
    
    local config = BOSS_CONFIGS[boss.Name]
    if not config then
        Utils.log("No config for boss: " .. boss.Name, "warn")
        return
    end
    
    State.currentBoss = boss.Name
    State.healthThreshold = pData.humanoid.MaxHealth * 0.5
    
    Animation.setup(boss, config)
    
    Utils.log("Farming " .. boss.Name .. "...")
    Utils.notify("Farming " .. boss.Name .. "...", 3)
    
    -- Start systems
    local attackThread = Combat.startAttacking()
    Combat.enableNoclip()
    Teleport.toBoss(boss, config)
    
    -- Monitor loop
    Farm.monitorLoop(boss)
    
    -- Cleanup
    if attackThread then
        pcall(function() task.cancel(attackThread) end)
    end
    Animation.cleanup(boss)
end

function Farm.monitorLoop(boss)
    local settings = getgenv().BossFarmSettings
    local lastPlayerCheck = tick()
    
    while State.running and State.currentBoss == boss.Name do
        local pData = Utils.getPlayerData()
        if not pData then break end
        
        -- Health check
        if pData.humanoid.Health < State.healthThreshold then
            Utils.log("Health low! Going to safe spot...")
            Farm.cleanup()
            Teleport.toSafeSpot(true)
            task.wait(3)
            break
        end
        
        -- Boss defeated check
        if not Utils.isValidBoss(boss) then
            Utils.log("Boss defeated!")
            Utils.notify(boss.Name .. " defeated!", 3)
            break
        end
        
        -- Player check (every 2 seconds)
        if tick() - lastPlayerCheck >= 2 then
            lastPlayerCheck = tick()
            
            local nearby, playerName = Detection.isPlayerNearby(
                boss,
                settings.PlayerDetectionRadius
            )
            
            if nearby then
                Utils.log(string.format("Player %s detected!", playerName))
                Farm.cleanup()
                Teleport.toSafeSpot(true)
                task.wait(2)
                break
            end
        end
        
        task.wait(settings.HealthCheckInterval)
    end
end

-- ============================================
-- STATUS
-- ============================================
function BossFarm.getStatus()
    return {
        running = State.running,
        currentBoss = State.currentBoss,
        connectionCount = #State.connections
    }
end

-- ============================================
-- EXPORTS
-- ============================================
BossFarm.start = Farm.start
BossFarm.stop = Farm.stop
BossFarm.bossDatabase = bossDatabase
BossFarm.BOSS_CONFIGS = BOSS_CONFIGS

return BossFarm

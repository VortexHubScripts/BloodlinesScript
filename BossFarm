-- Boss Farm Module for Bloodlines (Rewritten)
-- Improved version with bug fixes and better stability

local BossFarm = {}

-- ============================================
-- SERVICES
-- ============================================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- ============================================
-- SETTINGS
-- ============================================
getgenv().BossFarmSettings = {
    Enabled = false,
    SelectedBoss = "Wooden Golem",
    ServerHopWhenComplete = true,
    RespawnWaitTime = 120,
    EnableHalloweenBossFarm = false,
    AttackInterval = 0.7,
    PlayerDetectionRadius = 100,
    HealthCheckInterval = 0.5
}

-- ============================================
-- BOSS CONFIGURATIONS
-- ============================================
local BOSS_CONFIGS = {
    ["Wooden Golem"] = {
        modelNames = {"Wooden Golem"},
        farmHeight = 15,
        safeHeight = 30,
        positionAbove = true,
        dangerousAnimations = {
            ["rbxassetid://120758909308511"] = true,
            ["rbxassetid://116907126244057"] = true
        },
        minPlayers = 10
    },
    
    ["Chakra Knight"] = {
        modelNames = {"Chakra Knight", "Hallowed Chakra Knight"},
        farmHeight = 15,
        safeHeight = 25,
        positionAbove = false,
        dangerousAnimations = {
            ["rbxassetid://10141233349"] = true
        },
        minPlayers = 10
    },
    
    ["Tairock"] = {
        modelNames = {"Tairock", "Hallowed Tairock"},
        farmHeight = 11,
        safeHeight = 30,
        positionAbove = false,
        dangerousAnimations = {},
        minPlayers = 10
    }
}

-- ============================================
-- CONSTANTS
-- ============================================
local SAFE_SPOT = Vector3.new(-2950.580, 321.173, -275.704)
local BOSS_DATABASE = {
    "Wooden Golem",
    "Chakra Knight",
    "Hallowed Chakra Knight",
    "Tairock",
    "Hallowed Tairock"
}

-- ============================================
-- STATE MANAGEMENT
-- ============================================
local State = {
    farmRunning = false,
    currentBoss = nil,
    connections = {},
    animationTrackers = {},
    lastBossPosition = nil,
    healthThresholdType = "max",
    farmThread = nil
}

-- ============================================
-- UTILITY FUNCTIONS
-- ============================================
local Utils = {}

function Utils.notify(title, text, duration)
    if _G.NotificationLib then
        _G.NotificationLib:MakeNotification({
            Title = title,
            Text = text,
            Duration = duration or 3
        })
    end
end

function Utils.log(message, level)
    local prefix = "[Boss Farm]"
    if level == "warn" then
        warn(prefix, message)
    elseif level == "error" then
        error(prefix .. " " .. message)
    else
        print(prefix, message)
    end
end

function Utils.getPlayerData()
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    
    if not rootPart or not humanoid then return nil end
    
    return {
        character = character,
        rootPart = rootPart,
        humanoid = humanoid
    }
end

function Utils.isHallowedBoss(bossName)
    return string.find(bossName, "Hallowed") ~= nil
end

function Utils.getBaseBossName(bossName)
    return string.gsub(bossName, "Hallowed ", "")
end

function Utils.getBossConfig(modelName)
    for baseName, config in pairs(BOSS_CONFIGS) do
        for _, variant in ipairs(config.modelNames) do
            if variant == modelName then
                return config, baseName
            end
        end
    end
    return nil, nil
end

function Utils.isValidBoss(boss)
    if not boss or not boss.Parent or not boss:IsA("Model") then
        return false
    end
    
    local humanoid = boss:FindFirstChildOfClass("Humanoid")
    local rootPart = boss:FindFirstChild("HumanoidRootPart")
    
    return humanoid and rootPart and humanoid.Health > 0
end

function Utils.getInDanger()
    return getgenv().inDanger or false
end

function Utils.disconnectAll(connections)
    for i = #connections, 1, -1 do
        local connection = connections[i]
        if connection and typeof(connection) == "RBXScriptConnection" then
            pcall(function() connection:Disconnect() end)
        end
        connections[i] = nil
    end
end

-- ============================================
-- BOSS ESP SYSTEM
-- ============================================
getgenv().BossESPSettings = {
    Enabled = false,
    Show = {
        Name = true,
        Health = true,
        Distance = true,
    },
    TextSize = 18,
    MaxDistance = 99999
}

getgenv().ActiveBossESP = {}

local ESP = {}

function ESP.create(boss)
    if not boss or getgenv().ActiveBossESP[boss] then return end
    
    local esp = {
        NameText = Drawing.new("Text"),
        HealthText = Drawing.new("Text"),
        active = true
    }
    
    esp.NameText.Color = Color3.fromRGB(255, 0, 0)
    esp.NameText.Size = getgenv().BossESPSettings.TextSize
    esp.NameText.Outline = true
    esp.NameText.Center = true
    esp.NameText.Visible = false
    
    esp.HealthText.Color = Color3.fromRGB(0, 255, 0)
    esp.HealthText.Size = getgenv().BossESPSettings.TextSize
    esp.HealthText.Outline = true
    esp.HealthText.Center = true
    esp.HealthText.Visible = false
    
    getgenv().ActiveBossESP[boss] = esp
    
    ESP.update(boss, esp)
    
    boss.Destroying:Connect(function()
        ESP.remove(boss)
    end)
end

function ESP.update(boss, esp)
    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not esp.active or not getgenv().BossESPSettings.Enabled or not Utils.isValidBoss(boss) then
            esp.NameText.Visible = false
            esp.HealthText.Visible = false
            
            if not Utils.isValidBoss(boss) then
                ESP.remove(boss)
                if connection then connection:Disconnect() end
            end
            return
        end
        
        local rootPart = boss:FindFirstChild("HumanoidRootPart")
        local humanoid = boss:FindFirstChildOfClass("Humanoid")
        local camera = workspace.CurrentCamera
        
        if not rootPart or not humanoid or not camera then
            esp.NameText.Visible = false
            esp.HealthText.Visible = false
            return
        end
        
        local vector, onScreen = camera:WorldToViewportPoint(rootPart.Position)
        
        if not onScreen then
            esp.NameText.Visible = false
            esp.HealthText.Visible = false
            return
        end
        
        local distance = (camera.CFrame.Position - rootPart.Position).Magnitude
        local settings = getgenv().BossESPSettings
        
        if distance > settings.MaxDistance then
            esp.NameText.Visible = false
            esp.HealthText.Visible = false
            return
        end
        
        local info = {}
        if settings.Show.Name then
            table.insert(info, "[" .. boss.Name .. "]")
        end
        if settings.Show.Distance then
            table.insert(info, string.format("[%dm]", math.floor(distance)))
        end
        
        esp.NameText.Text = table.concat(info, " ")
        esp.NameText.Size = settings.TextSize
        esp.NameText.Position = Vector2.new(vector.X, vector.Y - 20)
        esp.NameText.Visible = true
        
        if settings.Show.Health and humanoid.Health > 0 then
            esp.HealthText.Text = string.format("[%d/%d HP]", 
                math.floor(humanoid.Health), 
                math.floor(humanoid.MaxHealth))
            esp.HealthText.Size = settings.TextSize
            esp.HealthText.Position = Vector2.new(vector.X, vector.Y)
            esp.HealthText.Visible = true
        else
            esp.HealthText.Visible = false
        end
    end)
end

function ESP.remove(boss)
    local esp = getgenv().ActiveBossESP[boss]
    if esp then
        esp.active = false
        pcall(function() esp.NameText:Remove() end)
        pcall(function() esp.HealthText:Remove() end)
        getgenv().ActiveBossESP[boss] = nil
    end
end

function ESP.initialize()
    -- Scan existing bosses
    for _, child in pairs(workspace:GetChildren()) do
        if table.find(BOSS_DATABASE, child.Name) and child:IsA("Model") then
            task.spawn(ESP.create, child)
        end
    end
    
    -- Monitor new bosses
    workspace.ChildAdded:Connect(function(child)
        if table.find(BOSS_DATABASE, child.Name) and child:IsA("Model") then
            task.wait(0.1) -- Small delay to ensure model is fully loaded
            ESP.create(child)
        end
    end)
end

-- ============================================
-- BOSS DETECTION
-- ============================================
local BossDetection = {}

function BossDetection.findBoss(bossName)
    local halloweenMode = getgenv().BossFarmSettings.EnableHalloweenBossFarm
    
    for _, child in pairs(workspace:GetChildren()) do
        if not Utils.isValidBoss(child) then continue end
        
        local baseName = Utils.getBaseBossName(child.Name)
        local isHallowed = Utils.isHallowedBoss(child.Name)
        
        if halloweenMode then
            if isHallowed and baseName == bossName then
                Utils.log("Found Hallowed variant: " .. child.Name)
                return child
            end
        else
            if child.Name == bossName or baseName == bossName then
                return child
            end
        end
    end
    
    return nil
end

function BossDetection.isPlayerNearby(boss, maxDistance)
    local rootPart = boss:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            if character then
                local playerRoot = character:FindFirstChild("HumanoidRootPart")
                if playerRoot then
                    local distance = (playerRoot.Position - rootPart.Position).Magnitude
                    if distance <= maxDistance then
                        return true, player.Name, math.floor(distance)
                    end
                end
            end
        end
    end
    
    return false
end

-- ============================================
-- ANIMATION TRACKING
-- ============================================
local AnimationTracker = {}

function AnimationTracker.setup(boss, config)
    if State.animationTrackers[boss] then return end
    
    local humanoid = boss:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return end
    
    State.animationTrackers[boss] = {
        dangerous = false,
        currentAnimId = nil
    }
    
    local connection = animator.AnimationPlayed:Connect(function(track)
        local animId = track.Animation.AnimationId
        
        if config.dangerousAnimations[animId] then
            Utils.log("Dangerous animation detected: " .. animId)
            State.animationTrackers[boss].dangerous = true
            State.animationTrackers[boss].currentAnimId = animId
            
            track.Stopped:Connect(function()
                Utils.log("Dangerous animation ended: " .. animId)
                if State.animationTrackers[boss] then
                    State.animationTrackers[boss].dangerous = false
                    State.animationTrackers[boss].currentAnimId = nil
                end
            end)
        end
    end)
    
    table.insert(State.connections, connection)
end

function AnimationTracker.isDangerous(boss)
    local tracker = State.animationTrackers[boss]
    return tracker and tracker.dangerous or false
end

function AnimationTracker.cleanup(boss)
    State.animationTrackers[boss] = nil
end

-- ============================================
-- TELEPORT SYSTEM
-- ============================================
local Teleport = {}

function Teleport.toSafeSpot(continuous)
    local playerData = Utils.getPlayerData()
    if not playerData then return nil end
    
    Utils.log("Teleporting to safe spot" .. (continuous and " (continuous)" or ""))
    Utils.notify("Boss Farm", "Moving to safe spot...", 2)
    
    if not continuous then
        playerData.rootPart.CFrame = CFrame.new(SAFE_SPOT)
        return nil
    end
    
    local connection = RunService.Heartbeat:Connect(function()
        if playerData.rootPart and playerData.rootPart.Parent then
            playerData.rootPart.CFrame = CFrame.new(SAFE_SPOT)
        end
    end)
    
    table.insert(State.connections, connection)
    return connection
end

function Teleport.toBoss(boss, config)
    if not Utils.isValidBoss(boss) then return nil end
    
    local playerData = Utils.getPlayerData()
    if not playerData then return nil end
    
    local bossRoot = boss:FindFirstChild("HumanoidRootPart")
    if not bossRoot then return nil end
    
    State.lastBossPosition = bossRoot.Position
    
    local connection = RunService.Heartbeat:Connect(function()
        if not State.farmRunning or not getgenv().BossFarmSettings.Enabled then return end
        
        local pData = Utils.getPlayerData()
        if not pData then return end
        
        -- Update last known position if boss still exists
        if bossRoot and bossRoot.Parent then
            State.lastBossPosition = bossRoot.Position
        end
        
        -- Determine height based on animation state
        local isDangerous = AnimationTracker.isDangerous(boss)
        local height = isDangerous and config.safeHeight or config.farmHeight
        
        -- Calculate position (above or below)
        local yOffset = config.positionAbove and height or -height
        local targetPos = State.lastBossPosition + Vector3.new(0, yOffset, 0)
        local lookAt = CFrame.new(targetPos, State.lastBossPosition)
        
        pData.rootPart.CFrame = lookAt
    end)
    
    table.insert(State.connections, connection)
    return connection
end

-- ============================================
-- SERVER HOP SYSTEM
-- ============================================
local ServerHop = {}

function ServerHop.execute()
    Utils.log("Initiating server hop...")
    
    -- Wait if in danger
    if Utils.getInDanger() then
        Utils.log("Player in combat! Waiting for safety...")
        Utils.notify("Boss Farm", "In combat! Waiting...", 3)
        
        Teleport.toSafeSpot(false)
        
        while Utils.getInDanger() do
            task.wait(0.5)
        end
        
        Utils.log("Out of combat! Proceeding with server hop...")
        Utils.notify("Boss Farm", "Server hopping now...", 3)
        task.wait(1)
    end
    
    local maxAttempts = 5
    
    for attempt = 1, maxAttempts do
        Utils.log(string.format("Server hop attempt %d/%d", attempt, maxAttempts))
        
        local success = pcall(function()
            local playerGui = LocalPlayer:WaitForChild("PlayerGui", 5)
            if not playerGui then return end
            
            local clientGui = playerGui:WaitForChild("ClientGui", 5)
            if not clientGui then return end
            
            -- Try to find server list
            local list = ServerHop.findServerList(clientGui)
            if not list then
                Utils.log("Could not find server list", "warn")
                return
            end
            
            -- Find valid servers
            local validServers = ServerHop.getValidServers(list)
            
            if #validServers == 0 then
                Utils.log("No valid servers found", "warn")
                return
            end
            
            -- Join random valid server
            local randomServer = validServers[math.random(1, #validServers)]
            Utils.log(string.format("Joining server with %d players...", randomServer.playerCount))
            
            for _, connection in pairs(getconnections(randomServer.button.MouseButton1Click)) do
                connection:Fire()
            end
        end)
        
        if not success then
            Utils.log("Server hop attempt failed", "warn")
        end
        
        task.wait(2)
        
        if attempt < maxAttempts then
            Utils.notify("Boss Farm", string.format("Retry %d/%d", attempt + 1, maxAttempts), 2)
        else
            Utils.log("Max server hop attempts reached")
            Utils.notify("Boss Farm", "Failed to find available server", 3)
        end
    end
end

function ServerHop.findServerList(clientGui)
    -- Try Mainframe path
    local mainframe = clientGui:FindFirstChild("Mainframe")
    if mainframe then
        local rest = mainframe:FindFirstChild("Rest")
        if rest then
            local serverList = rest:FindFirstChild("ServerList")
            if serverList then
                local backdrop = serverList:FindFirstChild("BackDrop")
                if backdrop then
                    local list = backdrop:FindFirstChild("List")
                    if list and #list:GetChildren() > 0 then
                        return list
                    end
                end
            end
        end
    end
    
    -- Try MenuScreen path
    local menuScreen = clientGui:FindFirstChild("MenuScreen")
    if menuScreen then
        local serverList = menuScreen:FindFirstChild("ServerList")
        if serverList then
            local backdrop = serverList:FindFirstChild("BackDrop")
            if backdrop then
                return backdrop:FindFirstChild("List")
            end
        end
    end
    
    return nil
end

function ServerHop.getValidServers(list)
    local validServers = {}
    local minPlayers = BOSS_CONFIGS[getgenv().BossFarmSettings.SelectedBoss].minPlayers or 10
    
    for _, frame in ipairs(list:GetChildren()) do
        if frame:IsA("Frame") and frame.Name == "ServerTemplate" then
            local playersLabel = frame:FindFirstChild("Players")
            local joinButton = frame:FindFirstChild("JoinButton")
            
            if playersLabel and joinButton and joinButton:IsA("TextButton") then
                local playerCount = tonumber(playersLabel.Text:match("%d+"))
                
                if playerCount and playerCount >= minPlayers then
                    table.insert(validServers, {
                        frame = frame,
                        button = joinButton,
                        playerCount = playerCount
                    })
                end
            end
        end
    end
    
    return validServers
end

-- ============================================
-- COMBAT SYSTEM
-- ============================================
local Combat = {}

function Combat.startAttacking()
    local dataEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("DataEvent")
    local settings = getgenv().BossFarmSettings
    
    local attackThread = task.spawn(function()
        while State.farmRunning and State.currentBoss do
            task.wait(settings.AttackInterval)
            
            if State.farmRunning and State.currentBoss then
                pcall(function()
                    dataEvent:FireServer("CheckMeleeHit", nil, "NormalAttack", false)
                end)
            end
        end
    end)
    
    return attackThread
end

function Combat.enableNoclip()
    local connection = RunService.Stepped:Connect(function()
        if not State.farmRunning or not getgenv().BossFarmSettings.Enabled then return end
        
        local playerData = Utils.getPlayerData()
        if not playerData then return end
        
        for _, part in pairs(playerData.character:GetDescendants()) do
            if part:IsA('BasePart') then
                part.CanCollide = false
            end
        end
    end)
    
    table.insert(State.connections, connection)
    return connection
end

-- ============================================
-- BOSS FARMING LOGIC
-- ============================================
local Farm = {}

function Farm.start()
    if State.farmRunning then
        Utils.log("Farm already running", "warn")
        return
    end
    
    State.farmThread = task.spawn(function()
        State.farmRunning = true
        
        local halloweenMode = getgenv().BossFarmSettings.EnableHalloweenBossFarm
        local modeText = halloweenMode and " [HALLOWEEN MODE]" or ""
        
        Utils.log("Boss auto-farm started!" .. modeText)
        Utils.notify("Boss Farm", "Auto-farm started!" .. modeText, 3)
        
        while getgenv().BossFarmSettings.Enabled do
            Farm.cleanup()
            
            local selectedBoss = getgenv().BossFarmSettings.SelectedBoss
            local boss = BossDetection.findBoss(selectedBoss)
            
            if not boss then
                local respawned = Farm.waitForRespawn(selectedBoss)
                
                if not respawned then
                    if getgenv().BossFarmSettings.ServerHopWhenComplete then
                        Teleport.toSafeSpot(false)
                        task.wait(0.5)
                        ServerHop.execute()
                        break
                    else
                        Utils.log("Server hop disabled, stopping farm...")
                        break
                    end
                end
                
                boss = BossDetection.findBoss(selectedBoss)
            end
            
            if boss then
                -- Check for nearby players
                local playerNearby, playerName = BossDetection.isPlayerNearby(
                    boss, 
                    getgenv().BossFarmSettings.PlayerDetectionRadius
                )
                
                if playerNearby then
                    Utils.log(string.format("Player %s nearby, waiting...", playerName))
                    task.wait(5)
                    continue
                end
                
                -- Farm the boss
                Farm.farmBoss(boss)
                task.wait(0.3)
            end
        end
        
        State.farmRunning = false
        State.currentBoss = nil
        Utils.log("Boss farm stopped")
    end)
end

function Farm.stop()
    getgenv().BossFarmSettings.Enabled = false
    State.farmRunning = false
    State.currentBoss = nil
    
    Farm.cleanup()
    
    if State.farmThread then
        pcall(function() task.cancel(State.farmThread) end)
        State.farmThread = nil
    end
    
    Utils.log("Boss farm stopped")
    Utils.notify("Boss Farm", "Auto-farm stopped", 2)
end

function Farm.cleanup()
    Utils.disconnectAll(State.connections)
    
    -- Cleanup animation trackers
    for boss, _ in pairs(State.animationTrackers) do
        AnimationTracker.cleanup(boss)
    end
end

function Farm.waitForRespawn(selectedBoss)
    local halloweenMode = getgenv().BossFarmSettings.EnableHalloweenBossFarm
    local searchText = halloweenMode and ("Hallowed " .. selectedBoss) or selectedBoss
    
    Utils.log("Boss not found, waiting for respawn...")
    Utils.notify("Boss Farm", "Waiting for " .. searchText .. "...", 3)
    
    local waitStartTime = tick()
    local waitTime = getgenv().BossFarmSettings.RespawnWaitTime
    local boss = nil
    
    while not boss and (tick() - waitStartTime) < waitTime do
        if not getgenv().BossFarmSettings.Enabled then
            return false
        end
        
        task.wait(2)
        boss = BossDetection.findBoss(selectedBoss)
    end
    
    if not boss then
        Utils.log("Boss did not respawn in time!")
        Utils.notify("Boss Farm", searchText .. " did not respawn!", 3)
        return false
    end
    
    return true
end

function Farm.farmBoss(boss)
    local playerData = Utils.getPlayerData()
    if not playerData then
        Utils.log("Could not get player data", "warn")
        return
    end
    
    local config, configName = Utils.getBossConfig(boss.Name)
    if not config then
        Utils.log("No config found for boss: " .. boss.Name, "warn")
        return
    end
    
    State.currentBoss = boss.Name
    
    -- Setup
    AnimationTracker.setup(boss, config)
    
    -- Calculate health threshold
    local healthThreshold
    if State.healthThresholdType == "max" then
        healthThreshold = playerData.humanoid.MaxHealth * 0.5
    else
        healthThreshold = playerData.humanoid.Health * 0.5
    end
    
    local hallowedText = Utils.isHallowedBoss(boss.Name) and " [HALLOWED]" or ""
    Utils.log("Farming " .. boss.Name .. hallowedText .. "...")
    Utils.notify("Boss Farm", "Farming " .. boss.Name .. hallowedText, 3)
    
    -- Start combat systems
    local attackThread = Combat.startAttacking()
    Combat.enableNoclip()
    Teleport.toBoss(boss, config)
    
    -- Main farming loop
    local exitReason = Farm.monitorFarmLoop(boss, healthThreshold)
    
    -- Cleanup
    if attackThread then
        pcall(function() task.cancel(attackThread) end)
    end
    AnimationTracker.cleanup(boss)
    
    Utils.log("Exiting farm loop: " .. exitReason)
end

function Farm.monitorFarmLoop(boss, healthThreshold)
    local settings = getgenv().BossFarmSettings
    local checkInterval = settings.HealthCheckInterval
    local lastPlayerCheck = tick()
    
    while State.farmRunning and State.currentBoss == boss.Name do
        local playerData = Utils.getPlayerData()
        if not playerData then
            return "player_data_lost"
        end
        
        -- Health check
        if playerData.humanoid.Health < healthThreshold then
            Utils.log(string.format("Health below threshold! (%.1f < %.1f)", 
                playerData.humanoid.Health, healthThreshold))
            
            State.healthThresholdType = "current"
            Farm.cleanup()
            Teleport.toSafeSpot(true)
            task.wait(2)
            
            return "low_health"
        end
        
        -- Boss defeated check
        if not Utils.isValidBoss(boss) then
            Utils.log("Boss defeated!")
            Utils.notify("Boss Farm", boss.Name .. " defeated!", 3)
            return "boss_defeated"
        end
        
        -- Periodic player proximity check (every 2 seconds)
        if tick() - lastPlayerCheck >= 2 then
            lastPlayerCheck = tick()
            
            local playerNearby, playerName, distance = BossDetection.isPlayerNearby(
                boss, 
                settings.PlayerDetectionRadius
            )
            
            if playerNearby then
                Utils.log(string.format("Player %s detected at %dm!", playerName, distance))
                Farm.cleanup()
                Teleport.toSafeSpot(true)
                task.wait(2)
                return "player_nearby"
            end
        end
        
        task.wait(checkInterval)
    end
    
    return "farm_stopped"
end

-- ============================================
-- STATUS FUNCTIONS
-- ============================================
function BossFarm.getStatus()
    return {
        running = State.farmRunning,
        currentTarget = State.currentBoss,
        healthThresholdType = State.healthThresholdType,
        activeConnections = #State.connections
    }
end

-- ============================================
-- INITIALIZATION
-- ============================================
function BossFarm.initialize()
    Utils.log("Initializing Boss Farm Module...")
    ESP.initialize()
    Utils.log("Boss Farm Module loaded successfully!")
end

-- ============================================
-- EXPORTS
-- ============================================
BossFarm.start = Farm.start
BossFarm.stop = Farm.stop
BossFarm.bossDatabase = BOSS_DATABASE
BossFarm.BOSS_CONFIGS = BOSS_CONFIGS

-- Auto-initialize
task.spawn(BossFarm.initialize)

return BossFarm
